// Service Worker b√°sico para Neptus - N√£o bloqueia acesso offline
const CACHE_NAME = "neptus-basic-v1";

// Lista de recursos essenciais para cache
const ESSENTIAL_RESOURCES = [
  "/login",
  "/_next/static/css/",
  "/_next/static/chunks/",
  "/images/",
  "/fonts/",
];

// Instala e faz cache b√°sico
self.addEventListener("install", (event) => {
  console.log("üì¶ SW: Instalando...");
  self.skipWaiting(); // For√ßa ativa√ß√£o imediata
});

// Ativa e assume controle
self.addEventListener("activate", (event) => {
  console.log("üöÄ SW: Ativando...");
  event.waitUntil(
    Promise.all([
      // Limpa caches antigos
      caches
        .keys()
        .then((cacheNames) =>
          Promise.all(
            cacheNames
              .filter((cacheName) => cacheName !== CACHE_NAME)
              .map((cacheName) => caches.delete(cacheName))
          )
        ),
      // Assume controle imediato
      self.clients.claim(),
    ])
  );
});

// Intercepta requests - NUNCA bloqueia navega√ß√£o
self.addEventListener("fetch", (event) => {
  const { request } = event;

  // Ignora requests n√£o-HTTP
  if (!request.url.startsWith("http")) return;

  const url = new URL(request.url);

  // Para navega√ß√£o (p√°ginas HTML)
  if (request.mode === "navigate") {
    event.respondWith(
      // Sempre tenta rede primeiro, mas N√ÉO espera muito
      Promise.race([
        fetch(request).catch(() => {
          console.log("üì± SW: Rede falhou, permitindo acesso offline");
          throw new Error("Network failed");
        }),
        // Timeout de 2 segundos
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Timeout")), 2000)
        ),
      ]).catch(async () => {
        // Se falhou, tenta cache ou permite que a p√°gina carregue normalmente
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
          console.log("üì± SW: Servindo do cache");
          return cachedResponse;
        }

        // √öltimo recurso: deixa o navegador lidar com isso
        // Isso permite que a aplica√ß√£o Next.js lide com o offline
        console.log("üì± SW: Sem cache, deixando navegador lidar");
        return new Response("", { status: 200 });
      })
    );
    return;
  }

  // Para recursos est√°ticos, tenta cache primeiro
  if (
    url.pathname.includes("/_next/") ||
    url.pathname.includes("/images/") ||
    url.pathname.includes("/fonts/") ||
    request.destination === "style" ||
    request.destination === "script" ||
    request.destination === "image" ||
    request.destination === "font"
  ) {
    event.respondWith(
      caches.match(request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        return fetch(request)
          .then((response) => {
            // Se conseguiu buscar, salva no cache
            if (response && response.status === 200) {
              const responseClone = response.clone();
              caches.open(CACHE_NAME).then((cache) => {
                cache.put(request, responseClone);
              });
            }
            return response;
          })
          .catch(() => {
            // Se falhou, retorna resposta vazia mas n√£o bloqueia
            return new Response("", { status: 404 });
          });
      })
    );
    return;
  }

  // Para tudo mais (APIs, etc), deixa passar normalmente
  // N√ÉO intercepta para n√£o causar bloqueios
});

console.log("‚úÖ SW Neptus B√°sico: Carregado - Modo n√£o-bloqueante");
