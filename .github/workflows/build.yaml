name: üöÄ Fluxo de CI - Pipeline de Build, tagueamento + Push da imagem para gerada no Docker Hub

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: write
  id-token: write

jobs:
  validations:
    name: üìã Fazendo algumas valida√ß√µes importantes
    runs-on: ubuntu-latest
    steps:
      - name: üëΩ Clonando o Reposit√≥rio da Aplica√ß√£o
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.TAG_GITHUB_TOKEN }}

      - name: üìã Checando a exist√™ncia dos arquivos obrigat√≥rios
        run: |
          # Loop de verifica√ß√£o dos arquivos obrigat√≥rios:
          for file in Prod.dockerfile .build.env .deploy.env; do
            if [ ! -f "$file" ]; then
              echo "::error file=$file::Arquivo '$file' n√£o encontrado!"
              echo "‚õî Pipeline interrompida devido a arquivos faltantes. Parece que voc√™ n√£o criou o arquivo '$file'. Caso tenha d√∫vida v√° no Readme inical da Organiza√ß√£o Princial!"
              exit 1
            fi
          done          

      - name: üìã Verificando a exist√™ncia dos Secrets obrigat√≥rios üîë
        if: success()
        run: |
          if [ ! -n "${{ secrets.DOCKER_TOKEN_ACCESS }}" ]; then
            echo "::error::‚õî Pipeline interrompida. Parece que voc√™ n√£o criou o Secret 'DOCKER_TOKEN_ACCESS'. Caso tenha d√∫vida v√° no Readme inical da Organiza√ß√£o Princial!"
            exit 1
          fi
          if [ ! -n "${{ secrets.TAG_GITHUB_TOKEN }}" ]; then
            echo "::error::‚õî Pipeline interrompida. Parece que voc√™ n√£o criou o Secret 'TAG_GITHUB_TOKEN'. Caso tenha d√∫vida v√° no Readme inical da Organiza√ß√£o Princial!"
            exit 1
          fi     
          

      - name: üìã Verificando se o arquivo '.deploy.env' est√° com as informa√ß√µes obrigat√≥rias necess√°rias...
        if: success()
        run: |
          if ! grep -q "NOME_DO_PROJETO=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'NOME_DO_PROJETO' em seu arquivo: .deploy.env ."
            exit 1
          fi
          

          if ! grep -q "DOCKER_USERNAME=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'DOCKER_USERNAME' em seu arquivo: .deploy.env ."
            exit 1
          fi
          

          if ! grep -q "DOCKER_HUB_REPOSITORY_NAME=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'DOCKER_HUB_REPOSITORY_NAME' em seu arquivo: .deploy.env ."
            exit 1
          fi
          

          if ! grep -q "DOCKER_TOKEN_ACCESS=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'DOCKER_TOKEN_ACCESS' em seu arquivo: .deploy.env ."
            exit 1
          fi
          
          
  tag:
    name: üîñ Criando a Tag Release
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.version-tag.outputs.VERSION }}
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.TAG_GITHUB_TOKEN }}
    
      - name: Definindo a Tag da vers√£o (Tag Release)
        id: version-tag
        run: |
          LAST_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
          echo "√öltima vers√£o encontrada: $LAST_TAG"

          if [[ -z "$LAST_TAG" ]]; then
            NEW_VERSION="v1.0.0"
          else
            IFS='.' read -r MAJOR MINOR PATCH <<<"${LAST_TAG//v/}"
            if [[ "$PATCH" -lt 10 ]]; then
              PATCH=$((PATCH + 1))
            else
              PATCH=0
              MINOR=$((MINOR + 1))
            fi
            if [[ "$MINOR" -eq 10 ]]; then
              MINOR=0
              MAJOR=$((MAJOR + 1))
            fi

            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          fi

          echo "Nova vers√£o: $NEW_VERSION"
          echo "VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT


  build-e-push-image-docker:
    name: üéÇ Buildando e Postando a Imagem Docker do seu projeto
    needs: [validations, tag]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: üëΩ Clonando o Reposit√≥rio da Aplica√ß√£o
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.TAG_GITHUB_TOKEN }}


      - name: Criando e publicando nova tag no resposit√≥rio do Usu√°rio
        env:
          IMAGE_TAG: ${{ needs.tag.outputs.image_tag }}
        run: |
          git config --global user.name "[bot]-actions"
          git config --global user.email "[bot]-actions@users.noreply.github.com"

          git tag $IMAGE_TAG
          # Publicando a nova tag no reposit√≥rio do Github
          # git push https://${{ github.actor }}:${{ secrets.TAG_GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $IMAGE_TAG
          git push https://x-access-token:${{ secrets.TAG_GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $IMAGE_TAG


      - name: Preparando tudo para a cria√ß√£o da Imagem da aplica√ß√£o
        run: |
          resolved_env=".build.resolved.env"
          cp .build.env $resolved_env

          # Extraindo os placeholders no formato @NOME_SEGREDO@
          vars=$(grep -oE '@[A-Z0-9_]+@' .build.env | tr -d '@' | sort -u)

          # Secrets dispon√≠veis em JSON
          ALL_SECRETS='${{ toJson(secrets) }}'

          for var in $vars; do
            value=$(jq -r --arg key "$var" '.[$key]' <<< "$ALL_SECRETS")
            if [ "$value" = "null" ]; then
              echo "‚ùå Secret '$var' n√£o encontrado no reposit√≥rio!"
              exit 1
            fi

            sed -i "s|@$var@|$value|g" $resolved_env
          done


      - name: Preparando dados para o Deploy
        id: preparando-arquivo-deploy-secrets
        run: |
          resolved_deploy_env=".deploy.resolved.env"
          cp .deploy.env $resolved_deploy_env

          # Extraindo os placeholders no formato @NOME_SEGREDO@
          vars=$(grep -oE '@[A-Z0-9_]+@' .deploy.env | tr -d '@' | sort -u)

          # Secrets dispon√≠veis em JSON
          ALL_SECRETS='${{ toJson(secrets) }}'

          for var in $vars; do
            value=$(jq -r --arg key "$var" '.[$key]' <<< "$ALL_SECRETS")
            if [ "$value" = "null" ]; then
              echo "‚ùå Secret '$var' n√£o encontrado no reposit√≥rio!"
              exit 1
            fi

            sed -i "s|@$var@|$value|g" $resolved_deploy_env
            echo "${var}=${value}" >> $GITHUB_OUTPUT
          done

          
      - name: Preparando vari√°veis complementares para Build e Deploy
        id: deploy_env
        run: |
          while IFS=$'\n' read -r line; do
            if [[ -n "$line" && "$line" != \#* ]]; then
              IFS='=' read -r key value <<< "$line"
                # echo "${key}=${value}"
              echo "${key}=${value}" >> $GITHUB_OUTPUT
            fi
          done < .deploy.env


      - name: ‚õ¥Ô∏è Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}
          password: ${{ steps.preparando-arquivo-deploy-secrets.outputs.DOCKER_TOKEN_ACCESS }}
      

      - name: üê≥ Build e push da imagem Docker
        id: push-image-docker
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          file: ./Prod.dockerfile
          build-args:
            ENV_FILE=./.build.resolved.env
          push: true
          tags: |
            ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}/${{ steps.deploy_env.outputs.DOCKER_HUB_REPOSITORY_NAME }}:latest
            ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}/${{ steps.deploy_env.outputs.DOCKER_HUB_REPOSITORY_NAME }}:${{ needs.tag.outputs.image_tag }}
                        

            
      - name: üì¨ Preparando dados para reposit√≥rio de Infra
        env:
            IMAGE_TAG: ${{ needs.tag.outputs.image_tag }}
            NOME_PROJETO: ${{ steps.deploy_env.outputs.NOME_DO_PROJETO }}
            DOCKER_USER: ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}
            REPOSITORIO_INFRA: "testesDevOps/repoInfra"
        run: |
          PROJETO_PATH="projetos/$NOME_PROJETO/${{ steps.deploy_env.outputs.DOCKER_HUB_REPOSITORY_NAME }}"
          
          NOVA_SECRET="${DOCKER_USER}_DOCKER_TOKEN_ACCESS"
          sed -i "s/DOCKER_TOKEN_ACCESS=@[^@]*@/DOCKER_TOKEN_ACCESS=@${NOVA_SECRET}@/g" .deploy.env
          echo -e "\nTAG=$IMAGE_TAG" >> .deploy.env


          echo ${{ secrets.TAG_GITHUB_TOKEN }}   | gh auth login --with-token
          
          # Criando diret√≥rio tempor√°rio
          WORK_DIR="temp_repo_$(date +%s)"
          mkdir "$WORK_DIR"
          cd "$WORK_DIR"

          # definindo a branch "main"
          git config --global init.defaultBranch main
          
          # Inicializar reposit√≥rio e adicionar repo remoto
          git init
          git remote add origin "https://${{ secrets.TAG_GITHUB_TOKEN }}@github.com/${REPOSITORIO_INFRA}.git"
          
          # Configurar sparse checkout para estrutura m√≠nima
          git config core.sparseCheckout true
          echo "/*" > .git/info/sparse-checkout
          echo "!/*/" >> .git/info/sparse-checkout
          echo "/projetos/" >> .git/info/sparse-checkout
          
          # Fazer fetch e checkout
          git pull origin main || echo "‚ö†Ô∏è  Pull inicial falhou, continuando..."

          # Criar estrutura de diret√≥rios completa se n√£o existir
          echo "üîç Verificando estrutura de diret√≥rios..."
          if [ ! -d "$PROJETO_PATH" ]; then
            echo "üìÇ Criando estrutura: $PROJETO_PATH"
            mkdir -p "$PROJETO_PATH"
            
            # Garantir que a pasta projetos est√° sendo rastreada
            if [ ! -d "projetos" ]; then
              mkdir -p "projetos"
              touch "projetos/.gitkeep"
            fi
          fi

          # Copiar arquivo
          echo "üìÑ Copiando .deploy.env para $PROJETO_PATH/"
          cp ../.deploy.env "$PROJETO_PATH/"        


          # Commit e push
          git add -A
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  Nenhuma altera√ß√£o para commitar"
          else
            git commit -m "feat: Adiciona .deploy.env em $PROJETO_PATH"
            git push origin main
            echo "‚úÖ Arquivo enviado com sucesso!"
          fi

          # Limpeza
          cd ..
          rm -rf "$WORK_DIR"

          # Criando Secret no Repo de Infra
          gh secret set $NOVA_SECRET --body ${{ steps.preparando-arquivo-deploy-secrets.outputs.DOCKER_TOKEN_ACCESS }} --repo $REPOSITORIO_INFRA

