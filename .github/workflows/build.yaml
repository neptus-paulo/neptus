name: üöÄ Fluxo de CI - Pipeline de Build, tagueamento + Push da imagem para gerada no Docker Hub

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: write
  # id-token: write

jobs:
  validations:
    name: üìã Fazendo algumas valida√ß√µes importantes
    runs-on: ubuntu-latest
    steps:
      - name: üëΩ Clonando o Reposit√≥rio da Aplica√ß√£o
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
        #   token: ${{ secrets.TAG_GITHUB_TOKEN }}

      - name: üìã Checando a exist√™ncia dos arquivos obrigat√≥rios
        run: |
          # Loop de verifica√ß√£o dos arquivos obrigat√≥rios:
          for file in Prod.dockerfile .build.env .deploy.env; do
            if [ ! -f "$file" ]; then
              echo "::error file=$file::Arquivo '$file' n√£o encontrado!"
              echo "‚õî Pipeline interrompida devido a arquivos faltantes. Parece que voc√™ n√£o criou o arquivo '$file'. Caso tenha d√∫vida v√° no Readme inical da Organiza√ß√£o Princial!"
              exit 1
            fi
          done          

      - name: üìã Verificando a exist√™ncia dos Secrets obrigat√≥rios üîë
        if: success()
        run: |
          if [ ! -n "${{ secrets.DOCKER_TOKEN_ACCESS }}" ]; then
            echo "::error::‚õî Pipeline interrompida. Parece que voc√™ n√£o criou o Secret 'DOCKER_TOKEN_ACCESS'. Caso tenha d√∫vida v√° no Readme inical da Organiza√ß√£o Princial!"
            exit 1
          fi
          if [ ! -n "${{ secrets.TAG_GITHUB_TOKEN }}" ]; then
            echo "::error::‚õî Pipeline interrompida. Parece que voc√™ n√£o criou o Secret 'TAG_GITHUB_TOKEN'. Caso tenha d√∫vida v√° no Readme inical da Organiza√ß√£o Princial!"
            exit 1
          fi     
          

      - name: üìã Verificando se o arquivo '.deploy.env' est√° com as informa√ß√µes obrigat√≥rias necess√°rias...
        if: success()
        run: |
          if ! grep -q "NOME_DO_PROJETO=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'NOME_DO_PROJETO' em seu arquivo: .deploy.env ."
            exit 1
          fi
          

          if ! grep -q "DOCKER_USERNAME=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'DOCKER_USERNAME' em seu arquivo: .deploy.env ."
            exit 1
          fi
          

          if ! grep -q "DOCKER_HUB_REPOSITORY_NAME=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'DOCKER_HUB_REPOSITORY_NAME' em seu arquivo: .deploy.env ."
            exit 1
          fi
          

          if ! grep -q "DOCKER_TOKEN_ACCESS=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'DOCKER_TOKEN_ACCESS' em seu arquivo: .deploy.env ."
            exit 1
          fi

          if ! grep -q "PORT_EXPOSE=" ".deploy.env"; then
            echo "::error::‚õî Pipeline interrompida. Voc√™ precisa adicionar a vari√°vel 'PORT_EXPOSE' em seu arquivo: .deploy.env ."
            exit 1
          fi
          
          
  tag:
    name: üîñ Criando a Tag Release
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.version-tag.outputs.VERSION }}
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          # token: ${{ secrets.TAG_GITHUB_TOKEN }}
    
      - name: Definindo a Tag da vers√£o (Tag Release)
        id: version-tag
        run: |
          LAST_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
          echo "√öltima vers√£o encontrada: $LAST_TAG"

          if [[ -z "$LAST_TAG" ]]; then
            NEW_VERSION="v1.0.0"
          else
            IFS='.' read -r MAJOR MINOR PATCH <<<"${LAST_TAG//v/}"
            if [[ "$PATCH" -lt 10 ]]; then
              PATCH=$((PATCH + 1))
            else
              PATCH=0
              MINOR=$((MINOR + 1))
            fi
            if [[ "$MINOR" -eq 10 ]]; then
              MINOR=0
              MAJOR=$((MAJOR + 1))
            fi

            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          fi

          echo "Nova vers√£o: $NEW_VERSION"
          echo "VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT


  build-e-push-image-docker:
    name: üéÇ Buildando e Postando a Imagem Docker do seu projeto
    needs: [validations, tag]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: üëΩ Clonando o Reposit√≥rio da Aplica√ß√£o
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          # token: ${{ secrets.TAG_GITHUB_TOKEN }}


      - name: üìã Lendo Informa√ß√µes do .build.env - para a cria√ß√£o da Imagem da aplica√ß√£o
        id: build_env
        env:
          FILE_ENV: ".build.env"
        run: |
          # Criando o arquivo com as ENVs necess√°rias
          build_env=".build.resolved.env"

          # Enviando o nome do arquivo para Output
          echo "BUILD_ENV=$build_env" >> $GITHUB_OUTPUT

          # Secrets dispon√≠veis em JSON
          ALL_SECRETS='${{ toJson(secrets) }}'

          while IFS=$'\n' read -r line; do
            if [[ "$line" =~ [^[:space:]] && "$line" != \#* ]]; then
              IFS='=' read -r key value <<< "$line"
              if [[ "$value" =~ ^@.*@$ ]]; then
                # removendo a "@" do in√≠cio e final do secret
                env_value="${value:1:-1}"

                value_env=$(jq -r --arg key "$env_value" '.[$key]' <<< "$ALL_SECRETS")
                echo "${key}=${value_env}" >> $build_env

              else
                echo "${key}=${value}" >> $build_env
              fi
            fi
          done < $FILE_ENV


      - name: üìã Preparando informa√ß√µes para o Build
        id: deploy_env
        env:
          FILE_ENV: ".deploy.env"
        run: |
          # Secrets dispon√≠veis em JSON
          ALL_SECRETS='${{ toJson(secrets) }}'


          while IFS=$'\n' read -r line; do
            if [[ "$line" =~ [^[:space:]] && "$line" != \#* ]]; then
              IFS='=' read -r key value <<< "$line"
              if [[ "$value" =~ ^@.*@$ ]]; then
                # removendo a "@" do in√≠cio e final do secret
                env_value="${value:1:-1}"

                value_env=$(jq -r --arg key "$env_value" '.[$key]' <<< "$ALL_SECRETS")
                echo "${key}=${value_env}" >> $GITHUB_OUTPUT
              else
                echo "${key}=${value}" >> $GITHUB_OUTPUT
              fi
            fi
          done < $FILE_ENV

      
      - name: ‚è≥ Preparando Dockerfile para produ√ß√£o
        id: dockerfile
        env:
          FILE_ENV: ${{ steps.build_env.outputs.BUILD_ENV }}
          DOCKERFILE: "Prod.dockerfile"
        run: |
          # Dockerile tempor√°rio para build
          temp_dockerfile="TEMP_Prod.dockerfile"
          echo "TEMP_DOCKERFILE=$temp_dockerfile" >> $GITHUB_OUTPUT

          
          # Preparando o bloco de ENVs a ser inserido no Dockerfile
          ENV_BLOCK_FILE="$(mktemp)"

          while IFS= read -r LINE; do
            VAR_NAME="${LINE%%=*}"
            VAR_VALUE="${LINE#*=}"

            # remove aspas externas se houver
            VAR_VALUE="${VAR_VALUE%\"}"
            VAR_VALUE="${VAR_VALUE#\"}"

            echo "ENV ${VAR_NAME}=\"${VAR_VALUE}\"" >> "$ENV_BLOCK_FILE"
          done < $FILE_ENV

          # Busca no Prod.dockerfile o local onde o usu√°rio adicionou a string "#__ENVS__#" para inser√≠-las
          awk -v env_block="$ENV_BLOCK_FILE" '
            {
              print $0
              if ($0 ~ /#__ENVS__#/) {
                while ((getline line < env_block) > 0) {
                  print line
                }
                close(env_block)
              }
            }
          ' "$DOCKERFILE" > "$temp_dockerfile"
          

      - name: ‚õ¥Ô∏è Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}
          password: ${{ steps.deploy_env.outputs.DOCKER_TOKEN_ACCESS }}
      

      - name: üê≥ Build e push da imagem Docker
        id: push-image-docker
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          file: ${{ steps.dockerfile.outputs.TEMP_DOCKERFILE }}
          push: true
          tags: |
            ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}/${{ steps.deploy_env.outputs.DOCKER_HUB_REPOSITORY_NAME }}:latest
            ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}/${{ steps.deploy_env.outputs.DOCKER_HUB_REPOSITORY_NAME }}:${{ needs.tag.outputs.image_tag }}
   

 
      - name: ‚úçÔ∏è Criando e publicando nova tag no resposit√≥rio do Usu√°rio
        env:
          IMAGE_TAG: ${{ needs.tag.outputs.image_tag }}
        run: |
          git config --global user.name "[bot]-actions"
          git config --global user.email "[bot]-actions@users.noreply.github.com"

          git tag $IMAGE_TAG
          # Publicando a nova tag no reposit√≥rio do Github
          git push https://x-access-token:${{ secrets.TAG_GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $IMAGE_TAG


 
      - name: üì¨ Preparando dados para reposit√≥rio de Infra
        env:
            IMAGE_TAG: ${{ needs.tag.outputs.image_tag }}
            BUILD_ENV: ${{ steps.build_env.outputs.BUILD_ENV }}
            NOME_PROJETO: ${{ steps.deploy_env.outputs.NOME_DO_PROJETO }}
            DOCKER_USER: ${{ steps.deploy_env.outputs.DOCKER_USERNAME }}
            DOCKER_TOKEN_ACCESS: ${{ steps.deploy_env.outputs.DOCKER_TOKEN_ACCESS }}
            TEMP_DOCKERFILE: ${{ steps.dockerfile.outputs.TEMP_DOCKERFILE }}
            DEPLOY_ENV: ".deploy.env"
            REPOSITORIO_INFRA: "Deploy-to-RNP-K8s-Cluster/repoInfra"
        run: |
          PROJETO_PATH="projetos/$NOME_PROJETO/${{ steps.deploy_env.outputs.DOCKER_HUB_REPOSITORY_NAME }}"
          
          NOVA_SECRET="${DOCKER_USER}_DOCKER_TOKEN_ACCESS"
          sed -i "s/DOCKER_TOKEN_ACCESS=@[^@]*@/DOCKER_TOKEN_ACCESS=@${NOVA_SECRET}@/g" $DEPLOY_ENV
          echo -e "\nTAG=$IMAGE_TAG" >> $DEPLOY_ENV

          echo ${{ secrets.TAG_GITHUB_TOKEN }}   | gh auth login --with-token
          
          # Criando diret√≥rio tempor√°rio
          WORK_DIR="temp_repo_$(date +%s)"
          mkdir "$WORK_DIR"
          cd "$WORK_DIR"

          # definindo a branch "main"
          git config --global init.defaultBranch main
          
          # Inicializar reposit√≥rio e adicionar repo remoto
          git init
          git remote add origin "https://${{ secrets.TAG_GITHUB_TOKEN }}@github.com/${REPOSITORIO_INFRA}.git"
          
          # Configurar sparse checkout para estrutura m√≠nima
          git config core.sparseCheckout true
          echo "/*" > .git/info/sparse-checkout
          echo "!/*/" >> .git/info/sparse-checkout
          echo "/projetos/" >> .git/info/sparse-checkout
          
          # Fazer fetch e checkout
          git pull origin main || echo "‚ö†Ô∏è  Pull inicial falhou, continuando..."

          # Criar estrutura de diret√≥rios completa se n√£o existir
          echo "üîç Verificando estrutura de diret√≥rios..."
          if [ ! -d "$PROJETO_PATH" ]; then
            echo "üìÇ Criando estrutura: $PROJETO_PATH"
            mkdir -p "$PROJETO_PATH"
            
            # Garantir que a pasta projetos est√° sendo rastreada
            if [ ! -d "projetos" ]; then
              mkdir -p "projetos"
              touch "projetos/.gitkeep"
            fi
          fi

          # Copiar arquivo
          echo "üìÑ Copiando .deploy.env para $PROJETO_PATH/"
          cp "../$DEPLOY_ENV" "$PROJETO_PATH/"        


          # Commit e push
          git add -A
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  Nenhuma altera√ß√£o para commitar"
          else
            git commit -m "feat: Adiciona .deploy.env em $PROJETO_PATH"
            git push origin main
            echo "‚úÖ Arquivo enviado com sucesso!"
          fi

          # Limpeza
          cd ..
          rm -rf "$WORK_DIR"
          rm -f $TEMP_DOCKERFILE $BUILD_ENV

          # Criando Secret no Repo de Infra
          gh secret set $NOVA_SECRET --body $DOCKER_TOKEN_ACCESS --repo $REPOSITORIO_INFRA
